<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Koerec - 高速音声コーパス作成ツール</title>
    <link rel="preconnect" href="https://cdn.tailwindcss.com" crossorigin>
    <link rel="dns-prefetch" href="//cdn.tailwindcss.com">
    <link rel="preconnect" href="https://cdnjs.cloudflare.com" crossorigin>
    <link rel="dns-prefetch" href="//cdnjs.cloudflare.com">
    <meta name="description" content="Koerecは、ブラウザだけで高速に音声コーパスを作成できる無料ツール。台本選択、録音、ノーマライズ、ZIPエクスポートまでワンクリックで完了。">
    <meta name="robots" content="index, follow">
    <meta name="theme-color" content="#ffffff">
    <meta property="og:locale" content="ja_JP">
    <meta property="og:type" content="website">
    <meta property="og:title" content="Koerec - 高速音声コーパス作成ツール">
    <meta property="og:description" content="Koerecは、ブラウザだけで高速に音声コーパスを作成できる無料ツール。台本選択、録音、ノーマライズ、ZIPエクスポートまでワンクリックで完了。">
    <link rel="icon" href="assets/images/icons/favicon.ico">
    <link rel="icon" href="assets/images/icons/favicon.svg" type="image/svg+xml">
    <link rel="icon" href="assets/images/icons/favicon-32x32.png" sizes="32x32" type="image/png">
    <link rel="icon" href="assets/images/icons/favicon-16x16.png" sizes="16x16" type="image/png">
    <link rel="icon" href="assets/images/icons/favicon-96x96.png" sizes="96x96" type="image/png">
    <link rel="apple-touch-icon" href="assets/images/icons/apple-touch-icon.png" sizes="180x180">
    <link rel="manifest" href="site.webmanifest">
    <link rel="canonical" href="https://koerec.markn2000.com/">
    <meta property="og:url" content="https://koerec.markn2000.com/">
    <meta property="og:image" content="https://koerec.markn2000.com/assets/images/ogp_default.webp">
    <meta property="og:site_name" content="Koerec">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="Koerec - 高速音声コーパス作成ツール">
    <meta name="twitter:description" content="Koerecは、ブラウザだけで高速に音声コーパスを作成できる無料ツール。台本選択、録音、ノーマライズ、ZIPエクスポートまでワンクリックで完了。">
    <meta name="twitter:image" content="https://koerec.markn2000.com/assets/images/ogp_default.webp">
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        body { 
            font-family: 'Inter', 'Noto Sans JP', sans-serif; 
            -webkit-font-smoothing: antialiased; 
            -moz-osx-font-smoothing: grayscale; 
            background-image: url('assets/images/bg.png');
            background-repeat: repeat;
            background-attachment: fixed;
        }
        .record-btn.recording .fa-microphone { display: none; }
        .record-btn:not(.recording) .fa-stop { display: none; }
        .record-btn.recording { 
            animation: pulse 1.5s infinite; 
        }
        @keyframes pulse { 
            0% { box-shadow: 0 0 0 0 rgba(239, 68, 68, 0.7); } 
            70% { box-shadow: 0 0 0 12px rgba(239, 68, 68, 0); } 
            100% { box-shadow: 0 0 0 0 rgba(239, 68, 68, 0); } 
        }
        .loading-spinner {
            width: 1rem;
            height: 1rem;
            border: 2px solid #60a5fa;
            border-top-color: transparent;
            border-radius: 9999px;
            animation: spin 0.8s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .shortcut-key { 
            background-color: #f3f4f6; 
            border: 1px solid #d1d5db; 
            border-radius: 0.25rem; 
            padding: 0.1rem 0.4rem; 
            font-family: monospace; 
            font-size: 0.8em; 
            color: #374151; 
            box-shadow: 0 1px 1px rgba(0,0,0,0.1); 
        }
        .modal-overlay { 
            transition: opacity 0.3s ease; 
        }
        .script-editor {
            min-height: 200px;
            max-height: 400px;
            overflow-y: auto;
        }
    </style>
</head>
<body class="text-gray-800 min-h-screen">

    <noscript>
        このサイトはJavaScriptが有効である必要があります。Koerecはブラウザで音声コーパスを作成できるツールです。
    </noscript>

    <!-- グローバルナビ（左上固定） -->
    <nav class="fixed top-3 left-3 z-50 flex items-center space-x-2">
        <a href="https://markn2000.com/" class="px-3 py-1 bg-white/90 hover:bg-white text-gray-800 rounded-md border border-gray-300 shadow-sm text-sm" title="MarkNのホームページに移動">MarkNホームページへ</a>
        <button id="home-btn" class="px-3 py-1 bg-white/90 hover:bg-white text-gray-800 rounded-md border border-gray-300 shadow-sm text-sm" title="Koerecの初期ページに戻る">ホームへ戻る</button>
    </nav>

    <div id="app-container" class="w-full max-w-4xl mx-auto p-6 md:p-8 bg-white rounded-2xl shadow-xl mt-8 mb-8">
        
        <!-- 初期画面 -->
        <div id="initial-screen">
            <h1 class="text-4xl font-bold text-center mb-2">Koerec</h1>
            <p class="text-gray-600 text-center mb-8">高速音声コーパス作成ツール</p>
            
            <!-- 台本選択セクション -->
            <div class="mb-8">
                <h2 class="text-xl font-semibold mb-4">台本選択</h2>
                
                <!-- 台本リスト -->
                <div class="mb-6">
                    <label class="block text-sm font-medium text-gray-700 mb-2">台本リスト</label>
                    <div id="script-list" class="border border-gray-300 rounded-lg max-h-64 overflow-y-auto bg-white shadow-sm">
                        <!-- 動的に生成される -->
                    </div>
                </div>
                
                <!-- 選択中の台本プレビュー -->
                <div id="script-preview" class="mb-6 hidden">
                    <div class="border border-gray-300 rounded-lg bg-gray-50">
                        <div id="preview-header" class="flex items-center justify-between p-3 border-b border-gray-200 cursor-pointer hover:bg-gray-100">
                            <div class="flex items-center">
                                <i id="preview-icon" class="fas fa-chevron-right text-gray-500 mr-2"></i>
                                <span id="preview-title" class="font-medium text-gray-700"></span>
                            </div>
                            <button id="show-full-preview-btn" class="text-sm text-blue-600 hover:text-blue-800 px-2 py-1 rounded hover:bg-blue-50">詳細表示</button>
                        </div>
                        <div id="preview-content" class="hidden p-3">
                            <div id="preview-text" class="text-sm text-gray-600 whitespace-pre-line"></div>
                            <div class="mt-3 flex justify-between items-center">
                                <span id="preview-line-count" class="text-xs text-gray-500"></span>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- 台本編集エリア（折りたたみ式） -->
                <div class="mb-6">
                    <div class="border border-gray-300 rounded-lg">
                        <div id="editor-header" class="flex items-center justify-between p-3 border-b border-gray-200 cursor-pointer hover:bg-gray-50">
                            <div class="flex items-center">
                                <i id="editor-icon" class="fas fa-chevron-right text-gray-500 mr-2"></i>
                                <span class="font-medium text-gray-700">台本の追加</span>
                            </div>
                        </div>
                        <div id="editor-content" class="hidden p-3">
                            <textarea id="script-editor" class="w-full p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500 script-editor" placeholder="台本をここに貼り付けるか、上記のオプションから選択してください。1行に1つの文章を記述してください。

基本形式（テキスト）
おはようございます。
こんにちは。

複雑な形式（<ID>:<元テキスト（<ルビ>）>,<正規化テキスト>）
No.001:今日（きょう）の天気（てんき）。,キョウノテンキ。
No.002:明日（あした）は晴（は）れ。,アシタワハレ。"></textarea>
                            <div class="flex justify-between items-center mt-2">
                                <span id="script-line-count" class="text-sm text-gray-500">0行</span>
                                <div class="flex space-x-2">
                                    <input type="file" id="custom-script-upload" accept=".txt" class="hidden">
                                    <button id="import-script-btn" class="px-4 py-2 bg-green-500 hover:bg-green-600 text-white rounded-lg text-sm">ファイルからインポート</button>
                                    <button id="clear-script-btn" class="px-4 py-2 bg-gray-500 hover:bg-gray-600 text-white rounded-lg text-sm">クリア</button>
                                    <button id="save-script-btn" class="px-4 py-2 bg-blue-500 hover:bg-blue-600 text-white rounded-lg text-sm">リストに追加</button>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- エクスポート形式選択 -->
            <div class="mb-8">
                <h2 class="text-xl font-semibold mb-4">エクスポート形式</h2>
                <select id="export-format-select" class="w-full p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500 mb-4">
                    <!-- 動的に生成される -->
                </select>
                <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                    <div>
                        <label class="block text-sm font-medium text-gray-700 mb-2">話者名</label>
                        <input type="text" id="speaker-name" value="test_speaker" class="w-full p-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500">
                    </div>
                    <div>
                        <label class="block text-sm font-medium text-gray-700 mb-2">言語</label>
                        <input type="text" id="language" value="JP" class="w-full p-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500">
                    </div>
                </div>
            </div>
            
            <div class="flex flex-col items-center">
                <button id="start-btn" class="w-full max-w-sm bg-blue-500 hover:bg-blue-600 text-white font-bold py-3 px-6 rounded-lg shadow-md transition-transform transform hover:scale-105 disabled:bg-gray-400 disabled:cursor-not-allowed disabled:transform-none">
                    録音開始
                </button>
            </div>
            
            <!-- ライセンス情報 -->
            <div class="mt-8 pt-4 border-t border-gray-200">
                <div class="text-xs text-gray-500 text-center space-y-1">
                    <p>本ソフトウェアはMITライセンスの下で公開されています。</p>
                    <p>使用している文章データのライセンス:</p>
                    <p>• ITAコーパス: <a href="https://github.com/mmorise/ita-corpus" target="_blank" class="text-blue-600 hover:text-blue-800 underline">Unlicense</a></p>
                    <p>• ROHAN4600コーパス: <a href="https://github.com/mmorise/rohan4600" target="_blank" class="text-blue-600 hover:text-blue-800 underline">CC0-1.0</a></p>
                </div>
            </div>
        </div>

        <!-- 録音画面 -->
        <div id="recording-screen" class="hidden">
            <div class="flex justify-between items-center mb-4">
                <div class="flex items-center space-x-3">
                    <button id="back-btn" class="w-10 h-10 bg-gray-500 hover:bg-gray-600 text-white rounded-full flex items-center justify-center text-xl shadow-lg transition-transform transform hover:scale-110 disabled:bg-gray-400 disabled:cursor-not-allowed disabled:transform-none">
                        <i class="fas fa-arrow-left"></i>
                    </button>
                    <span class="shortcut-key">Backspace</span>
                </div>
                <span id="progress-indicator" class="text-sm font-semibold text-gray-500 bg-gray-200 px-3 py-1 rounded-full"></span>
            </div>
            <div id="text-display" class="bg-gray-50 p-6 rounded-lg text-center text-4xl font-semibold my-5 border border-gray-200 min-h-[150px] flex items-center justify-center"></div>
            <div class="w-full h-24 bg-gray-900 rounded-lg mb-5 overflow-hidden">
                <canvas id="waveform-canvas" class="w-full h-full"></canvas>
            </div>
            <!-- ステータスメッセージ -->
            <div class="text-center mb-6">
                <p id="status-text" class="text-lg text-gray-700 font-medium">録音してください</p>
            </div>
            
            <!-- ノイズ/ノーマライズ設定（横並び） -->
            <div class="flex items-center justify-center mb-4 space-x-6">
                <label class="flex items-center space-x-2 cursor-pointer">
                    <input type="checkbox" id="normalize-toggle" class="w-4 h-4 text-blue-600 bg-gray-100 border-gray-300 rounded focus:ring-blue-500 focus:ring-2">
                    <span class="text-sm text-gray-700">音量自動調整</span>
                </label>
                <label class="flex items-center space-x-2 cursor-pointer">
                    <input type="checkbox" id="noise-reduction-toggle" class="w-4 h-4 text-blue-600 bg-gray-100 border-gray-300 rounded focus:ring-blue-500 focus:ring-2">
                    <span class="text-sm text-gray-700">ノイズ除去</span>
                </label>
            </div>
            
            <!-- ボタン群 -->
            <div class="flex items-center justify-center space-x-8 mb-6">
                <div class="flex flex-col items-center">
                    <button id="record-btn" class="record-btn w-20 h-20 bg-red-500 hover:bg-red-600 text-white rounded-full flex items-center justify-center text-3xl shadow-lg transition-transform transform hover:scale-110 disabled:bg-gray-400 disabled:cursor-not-allowed disabled:transform-none">
                        <i class="fas fa-microphone"></i>
                        <i class="fas fa-stop"></i>
                    </button>
                    <span class="shortcut-key mt-2">Space</span>
                </div>
                <div class="flex flex-col items-center">
                    <div id="playback-controls">
                        <audio id="audio-player" class="hidden"></audio>
                        <button id="play-btn" class="w-20 h-20 bg-gray-400 text-white rounded-full flex items-center justify-center text-3xl shadow-lg transition-transform transform hover:scale-110 disabled:bg-gray-400 disabled:cursor-not-allowed disabled:transform-none">
                            <i class="fas fa-play"></i>
                        </button>
                    </div>
                    <span class="shortcut-key mt-2">P</span>
                </div>
                <div class="flex flex-col items-center">
                    <button id="next-btn" class="w-20 h-20 bg-green-500 hover:bg-green-600 text-white rounded-full flex items-center justify-center text-3xl shadow-lg transition-transform transform hover:scale-110 disabled:bg-gray-400 disabled:cursor-not-allowed">
                        <i class="fas fa-arrow-right"></i>
                    </button>
                    <span class="shortcut-key mt-2">Enter</span>
                </div>
            </div>
        </div>

        <!-- 完了画面 -->
        <div id="completion-screen" class="hidden text-center">
            <h1 class="text-3xl font-bold mb-4">録音完了！</h1>
            <p class="text-gray-600 mb-8">すべての文章の録音が完了しました。データ一式をダウンロードしてください。</p>
            <div id="download-spinner" class="hidden my-4">
                <div class="animate-spin rounded-full h-12 w-12 border-b-2 border-blue-500 mx-auto"></div>
                <p class="mt-2 text-sm text-gray-500">ファイルを生成中です...</p>
            </div>
            <button id="download-btn" class="w-full max-w-xs bg-indigo-500 hover:bg-indigo-600 text-white font-bold py-3 px-6 rounded-lg shadow-md transition-transform transform hover:scale-105">ダウンロード</button>
            
            <!-- 解凍時のセキュリティ警告対策 -->
            <div class="mt-6 p-4 bg-yellow-50 border border-yellow-200 rounded-lg text-left max-w-4xl mx-auto">
                <h3 class="text-lg font-semibold text-yellow-800 mb-3">⚠️ ZIPファイル解凍時の注意</h3>
                <p class="text-sm text-yellow-700 mb-3">
                    ZIPファイルを解凍する際に「問題を引き起こす可能性のあるファイルが見つかりました」と表示される場合があります。
                </p>
                <div class="text-sm text-yellow-700">
                    <p class="font-medium mb-2">対処方法：</p>
                    <ol class="list-decimal list-inside space-y-1">
                        <li>ダウンロードしたZIPファイルを右クリック</li>
                        <li>「プロパティ」を選択</li>
                        <li>「全般」タブの下部にある「セキュリティ」セクションを確認</li>
                        <li>「許可する」にチェックを入れる</li>
                        <li>「OK」をクリックして解凍を再試行</li>
                    </ol>
                </div>
                
                <!-- スクリーンショット表示エリア -->
                <div class="mt-4 grid grid-cols-1 md:grid-cols-2 gap-4">
                    <div class="text-center">
                        <h4 class="text-sm font-medium text-yellow-800 mb-2">プロパティをクリック</h4>
                        <img src="assets/images/スクリーンショット 2025-10-23 150007.webp" alt="プロパティ画面のスクリーンショット" loading="lazy" decoding="async" class="w-full max-w-sm mx-auto rounded-lg shadow-md border border-yellow-300">
                    </div>
                    <div class="text-center">
                        <h4 class="text-sm font-medium text-yellow-800 mb-2">許可するにチェック</h4>
                        <img src="assets/images/スクリーンショット 2025-10-23 150033.webp" alt="セキュリティ設定のスクリーンショット" loading="lazy" decoding="async" class="w-full max-w-sm mx-auto rounded-lg shadow-md border border-yellow-300">
                    </div>
                </div>
                
                <div class="mt-3 text-xs text-yellow-600">
                    ※ この警告はブラウザのセキュリティ機能によるもので、ファイル自体に問題はありません。
                </div>
            </div>
            
            <button id="restart-btn" class="mt-4 w-full max-w-xs bg-gray-500 hover:bg-gray-600 text-white font-bold py-3 px-6 rounded-lg shadow-md transition-transform transform hover:scale-105">最初からやり直す</button>
        </div>
    </div>
    
    <!-- 再開確認モーダル -->
    <div id="resume-modal" class="modal-overlay fixed inset-0 bg-gray-900 bg-opacity-50 flex items-center justify-center p-4 hidden opacity-0">
        <div class="bg-white rounded-lg shadow-xl p-6 max-w-sm w-full">
            <h3 class="text-lg font-bold mb-4">進捗の再開</h3>
            <p id="resume-text" class="text-gray-700 mb-6"></p>
            <div class="flex justify-end space-x-3">
                <button id="resume-new-btn" class="px-4 py-2 bg-gray-200 hover:bg-gray-300 rounded-lg">初めから</button>
                <button id="resume-continue-btn" class="px-4 py-2 bg-blue-500 hover:bg-blue-600 text-white rounded-lg">続きから再開</button>
            </div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // --- DOM Elements ---
            const initialScreen = document.getElementById('initial-screen');
            const recordingScreen = document.getElementById('recording-screen');
            const completionScreen = document.getElementById('completion-screen');
            const scriptList = document.getElementById('script-list');
            const customScriptUpload = document.getElementById('custom-script-upload');
            const importScriptBtn = document.getElementById('import-script-btn');
            const clearScriptBtn = document.getElementById('clear-script-btn');
            const scriptEditor = document.getElementById('script-editor');
            const scriptLineCount = document.getElementById('script-line-count');
            const saveScriptBtn = document.getElementById('save-script-btn');
            const exportFormatSelect = document.getElementById('export-format-select');
            const speakerName = document.getElementById('speaker-name');
            const language = document.getElementById('language');
            const startBtn = document.getElementById('start-btn');
            const backBtn = document.getElementById('back-btn');
            const progressIndicator = document.getElementById('progress-indicator');
            const textDisplay = document.getElementById('text-display');
            const recordBtn = document.getElementById('record-btn');
            const statusText = document.getElementById('status-text');
            const playbackControls = document.getElementById('playback-controls');
            const audioPlayer = document.getElementById('audio-player');
            const playBtn = document.getElementById('play-btn');
            const nextBtn = document.getElementById('next-btn');
            const downloadBtn = document.getElementById('download-btn');
            const downloadSpinner = document.getElementById('download-spinner');
            const restartBtn = document.getElementById('restart-btn');
            const canvas = document.getElementById('waveform-canvas');
            const canvasCtx = canvas.getContext('2d');
            const resumeModal = document.getElementById('resume-modal');
            const resumeText = document.getElementById('resume-text');
            const resumeNewBtn = document.getElementById('resume-new-btn');
            const resumeContinueBtn = document.getElementById('resume-continue-btn');
            const normalizeToggle = document.getElementById('normalize-toggle');
            const noiseReductionToggle = document.getElementById('noise-reduction-toggle');
            const homeBtn = document.getElementById('home-btn');
            // 初期画面では「ホームへ戻る」を非表示
            homeBtn.style.display = 'none';

            // --- 事前定義台本データ ---
            let predefinedScripts = {};

            // --- カスタム台本管理 ---
            let customScripts = {};
            let allScripts = { ...predefinedScripts, ...customScripts };

            // --- State Management ---
            let appState = 'idle';
            let mediaRecorder;
            let audioChunks = [];
            let currentScriptKey;
            let currentScript;
            let currentIndex = 0;
            let currentBlob = null;
            let stream;
            let audioContext;
            let analyser;
            let source;
            let animationFrameId;
            let db;
            let selectedScripts = [];
            let exportFormat = 'standard';
            let normalizeEnabled = false;
            let noiseReductionEnabled = false;
            let shouldWarnBeforeUnload = false; // 離脱警告フラグ
            
            // トリミング機能の状態管理
            let trimStart = 0;        // 開始位置（0-1の比率）
            let trimEnd = 1;          // 終了位置（0-1の比率）
            let isDraggingTrim = false; // トリミング線をドラッグ中かどうか
            let draggedTrimLine = null; // ドラッグ中の線（'start' または 'end'）
            let hoveredTrimLine = null; // ホバー中の線（'start' または 'end'）

            // --- IndexedDB Management ---
            const dbName = 'KoerecDB';
            const storeName = 'recordings';
            
            function initDB() {
                return new Promise((resolve, reject) => {
                    const request = indexedDB.open(dbName, 1);
                    request.onerror = e => reject("DB Error: " + e.target.errorCode);
                    request.onsuccess = e => { 
                        db = e.target.result; 
                        resolve(db); 
                    };
                    request.onupgradeneeded = e => {
                        const db = e.target.result;
                        if (!db.objectStoreNames.contains(storeName)) {
                            db.createObjectStore(storeName, { keyPath: 'id' });
                        }
                    };
                });
            }

            function dbAction(type, data = null) {
                return new Promise((resolve, reject) => {
                    if (!db) reject("DB not initialized");
                    const transaction = db.transaction([storeName], type === 'get' || type === 'getAll' ? 'readonly' : 'readwrite');
                    const store = transaction.objectStore(storeName);
                    const request = data ? store[type](data) : store[type]();
                    request.onerror = e => reject("Transaction Error: " + e.target.errorCode);
                    request.onsuccess = e => resolve(e.target.result);
                });
            }

            // エクスポート形式の読み込み
            let exportFormats = {};
            
            // 事前定義台本の読み込み
            async function loadPredefinedScripts() {
                try {
                    const manifestResponse = await fetch('scripts/manifest.json', { cache: 'no-cache' });
                    if (!manifestResponse.ok) {
                        throw new Error(`manifest.jsonの読み込みに失敗しました: HTTP ${manifestResponse.status}`);
                    }
                    const manifest = await manifestResponse.json();
                    const scriptFiles = manifest.scripts;

                    for (const fileName of scriptFiles) {
                        const scriptKey = fileName.replace('.txt', '');
                        predefinedScripts[scriptKey] = {
                            name: scriptKey,
                            lines: [],
                            isPredefined: true
                        };

                        try {
                            const response = await fetch(`scripts/${fileName}`, { cache: 'no-cache' });
                            if (!response.ok) {
                                console.warn(`${fileName}の読み込みに失敗しました: HTTP ${response.status}`);
                                continue;
                            }
                            const text = await response.text();
                            const lines = text.split('\n').filter(line => line.trim() !== '');
                            predefinedScripts[scriptKey].lines = lines;
                            console.log(`${fileName}を正常に読み込みました:`, lines.length + '行');
                        } catch (error) {
                            console.error(`${fileName}の読み込みに失敗しました:`, error);
                        }
                    }
                } catch (error) {
                    console.error('台本のマニフェストファイルの処理中にエラーが発生しました:', error);
                    // ここでエラー処理を追加できます（例：ユーザーへの通知）
                }

                // allScriptsを更新
                allScripts = { ...predefinedScripts, ...customScripts };
            }
            
            // テキスト解析関数
            function parseText(text) {
                // :以降の部分を取得
                const colonIndex = text.indexOf(':');
                if (colonIndex === -1) {
                    // :がない場合でも、`,` があるなら「表示用,正規化」の2項形式として扱う
                    const commaIndexAll = text.indexOf(',');
                    if (commaIndexAll === -1) {
                        // カンマもなければそのまま使用
                        return {
                            displayText: text,
                            normalizedText: text
                        };
                    }
                    // 先頭からのカンマで分割
                    return {
                        displayText: text.substring(0, commaIndexAll),
                        normalizedText: text.substring(commaIndexAll + 1)
                    };
                }
                
                const afterColon = text.substring(colonIndex + 1);
                
                // ,で分割
                const commaIndex = afterColon.indexOf(',');
                if (commaIndex === -1) {
                    // ,がない場合は表示用テキスト = 正規化テキスト
                    return {
                        displayText: afterColon,
                        normalizedText: afterColon
                    };
                }
                
                // ,がある場合は分割
                const displayText = afterColon.substring(0, commaIndex);
                const normalizedText = afterColon.substring(commaIndex + 1);
                
                return {
                    displayText: displayText,
                    normalizedText: normalizedText
                };
            }
            
            // ルビ（括弧内の文字）を除去する関数
            function removeRuby(text) {
                // 括弧とその中身を除去（例: 流(なが)し → 流し）
                return text.replace(/\([^)]*\)/g, '');
            }
            
            async function loadExportFormats() {
                try {
                    const response = await fetch('config/export_formats.json');
                    const data = await response.json();
                    exportFormats = data;
                    
                    // セレクトボックスを更新
                    updateExportFormatSelect();
                } catch (error) {
                    console.error('エクスポート形式の読み込みに失敗しました:', error);
                    // フォールバック用のデフォルト形式
                    exportFormats = {
                        formats: [
                            {
                                id: "style_bert_vits2",
                                name: "Style-BERT-VITS2等",
                                description: "音声ファイル名|話者名|言語|文章内容の形式",
                                outputFile: "esd.list",
                                format: "filename|speaker|language|text",
                                showSpeakerField: true,
                                showLanguageField: true
                            },
                            {
                                id: "ljspeech",
                                name: "LJSpeech",
                                description: "ファイル名ID|元のテキスト|正規化されたテキストの形式",
                                outputFile: "list.txt",
                                format: "filename_id|original_text|normalized_text",
                                showSpeakerField: false,
                                showLanguageField: false
                            },
                            {
                                id: "simple",
                                name: "シンプル",
                                description: "音声ファイル名|テキストの形式",
                                outputFile: "list.txt",
                                format: "filename|text",
                                showSpeakerField: false,
                                showLanguageField: false
                            }
                        ],
                        defaultFormat: "style_bert_vits2"
                    };
                    updateExportFormatSelect();
                }
            }
            
            function updateExportFormatSelect() {
                exportFormatSelect.innerHTML = '';
                exportFormats.formats.forEach(format => {
                    const option = document.createElement('option');
                    option.value = format.id;
                    option.textContent = `${format.name}（${format.description}）`;
                    if (format.id === exportFormats.defaultFormat) {
                        option.selected = true;
                        exportFormat = format.id;
                    }
                    exportFormatSelect.appendChild(option);
                });
                
                // 初期状態でフィールドの表示を更新
                updateFieldVisibility();
            }
            
            function updateFieldVisibility() {
                const selectedFormat = exportFormats.formats.find(f => f.id === exportFormat);
                if (!selectedFormat) return;
                
                const speakerField = document.getElementById('speaker-name').parentElement;
                const languageField = document.getElementById('language').parentElement;
                
                // 話者名フィールドの表示/非表示
                if (selectedFormat.showSpeakerField) {
                    speakerField.style.display = 'block';
                } else {
                    speakerField.style.display = 'none';
                }
                
                // 言語フィールドの表示/非表示
                if (selectedFormat.showLanguageField) {
                    languageField.style.display = 'block';
                } else {
                    languageField.style.display = 'none';
                }
            }

            // --- 初期化 ---
            async function initializeApp() {
                showScriptListLoading();
                // エクスポート形式の読み込み
                await loadExportFormats();
                
                // カスタム台本の読み込み
                loadCustomScripts();
                
                // 事前定義台本の読み込み
                await loadPredefinedScripts();

                // 台本リストの生成
                updateScriptList();

                // 台本エディタの行数カウント
                scriptEditor.addEventListener('input', updateLineCount);
                updateLineCount();

                // 台本保存
                saveScriptBtn.addEventListener('click', saveScript);

                // インポートボタン
                importScriptBtn.addEventListener('click', () => customScriptUpload.click());

                // クリアボタン
                clearScriptBtn.addEventListener('click', clearScriptEditor);

                // カスタム台本アップロード
                customScriptUpload.addEventListener('change', handleCustomScriptUpload);

                // エクスポート形式変更
                exportFormatSelect.addEventListener('change', (e) => {
                    exportFormat = e.target.value;
                    updateFieldVisibility();
                });

                // プレビュー機能の初期化
                initializePreview();

                // 折りたたみ式エディタの初期化
                initializeCollapsibleEditor();

                // 初期状態で録音開始ボタンを無効化
                document.getElementById('start-btn').disabled = true;

                // ノーマライズ設定の読み込み
                loadNormalizeSetting();

                // ノーマライズ設定の保存
                normalizeToggle.addEventListener('change', saveNormalizeSetting);

                // ノイズ除去設定の読み込み
                loadNoiseReductionSetting();

                // ノイズ除去設定の保存
                noiseReductionToggle.addEventListener('change', saveNoiseReductionSetting);

                // IndexedDB初期化
                initDB();
            }

            function updateLineCount() {
                const lines = scriptEditor.value.split('\n').filter(line => line.trim() !== '');
                scriptLineCount.textContent = `${lines.length}行`;
            }

            function clearScriptEditor() {
                scriptEditor.value = '';
                updateLineCount();
            }

            // --- ノーマライズ設定管理 ---
            function loadNormalizeSetting() {
                const saved = localStorage.getItem('normalize_enabled');
                if (saved !== null) {
                    normalizeEnabled = saved === 'true';
                    normalizeToggle.checked = normalizeEnabled;
                }
            }

            function saveNormalizeSetting() {
                normalizeEnabled = normalizeToggle.checked;
                localStorage.setItem('normalize_enabled', normalizeEnabled.toString());
            }

            // --- ノイズ除去設定管理 ---
            function loadNoiseReductionSetting() {
                const saved = localStorage.getItem('noise_reduction_enabled');
                if (saved !== null) {
                    noiseReductionEnabled = saved === 'true';
                    noiseReductionToggle.checked = noiseReductionEnabled;
                }
            }

            function saveNoiseReductionSetting() {
                noiseReductionEnabled = noiseReductionToggle.checked;
                localStorage.setItem('noise_reduction_enabled', noiseReductionEnabled.toString());
            }

            // --- ノーマライズ処理 ---
            async function normalizeAudio(audioBlob) {
                if (!audioContext) {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                }
                
                try {
                    // 音声データをデコード
                    const arrayBuffer = await audioBlob.arrayBuffer();
                    const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
                    
                    // 最大音量を検出
                    const channelData = audioBuffer.getChannelData(0);
                    let maxPeak = 0;
                    
                    for (let i = 0; i < channelData.length; i++) {
                        maxPeak = Math.max(maxPeak, Math.abs(channelData[i]));
                    }
                    
                    // ノーマライズゲインを計算（最大音量を98%に調整）
                    if (maxPeak > 0) {
                        const targetLevel = 0.98; // 98%
                        const normalizeGain = Math.min(targetLevel / maxPeak, 10.0); // 最大10倍まで
                        
                        // ゲインを適用して新しいAudioBufferを作成
                        const normalizedBuffer = audioContext.createBuffer(
                            audioBuffer.numberOfChannels,
                            audioBuffer.length,
                            audioBuffer.sampleRate
                        );
                        
                        for (let channel = 0; channel < audioBuffer.numberOfChannels; channel++) {
                            const inputData = audioBuffer.getChannelData(channel);
                            const outputData = normalizedBuffer.getChannelData(channel);
                            
                            for (let i = 0; i < inputData.length; i++) {
                                outputData[i] = inputData[i] * normalizeGain;
                            }
                        }
                        
                        // AudioBufferをBlobに変換
                        return await audioBufferToBlob(normalizedBuffer);
                    }
                    
                    return audioBlob; // ノーマライズ不要な場合は元のBlobを返す
                    
                } catch (error) {
                    console.error('ノーマライズ処理でエラーが発生しました:', error);
                    return audioBlob; // エラーの場合は元のBlobを返す
                }
            }
            
            // AudioBufferをBlobに変換する関数
            async function audioBufferToBlob(audioBuffer) {
                const numberOfChannels = audioBuffer.numberOfChannels;
                const sampleRate = audioBuffer.sampleRate;
                const length = audioBuffer.length;
                
                // WAVファイルのヘッダーを作成（モノラル用）
                const buffer = new ArrayBuffer(44 + length * 1 * 2);
                const view = new DataView(buffer);
                
                // WAVヘッダー
                const writeString = (offset, string) => {
                    for (let i = 0; i < string.length; i++) {
                        view.setUint8(offset + i, string.charCodeAt(i));
                    }
                };
                
                writeString(0, 'RIFF');
                view.setUint32(4, 36 + length * 1 * 2, true); // モノラル用に修正
                writeString(8, 'WAVE');
                writeString(12, 'fmt ');
                view.setUint32(16, 16, true);
                view.setUint16(20, 1, true);
                view.setUint16(22, 1, true); // 強制的にモノラル（1チャンネル）に設定
                view.setUint32(24, sampleRate, true);
                view.setUint32(28, sampleRate * 1 * 2, true); // モノラル用に修正
                view.setUint16(32, 1 * 2, true); // モノラル用に修正
                view.setUint16(34, 16, true);
                writeString(36, 'data');
                view.setUint32(40, length * 1 * 2, true); // モノラル用に修正
                
                // 音声データを書き込み（ステレオ→モノラル変換）
                let offset = 44;
                for (let i = 0; i < length; i++) {
                    let sample;
                    if (numberOfChannels === 1) {
                        // 既にモノラルの場合
                        sample = audioBuffer.getChannelData(0)[i];
                    } else {
                        // ステレオの場合、左右チャンネルを平均化してモノラルに変換
                        const leftChannel = audioBuffer.getChannelData(0)[i];
                        const rightChannel = audioBuffer.getChannelData(1)[i];
                        sample = (leftChannel + rightChannel) / 2;
                    }
                    
                    // クリッピング防止
                    sample = Math.max(-1, Math.min(1, sample));
                    view.setInt16(offset, sample < 0 ? sample * 0x8000 : sample * 0x7FFF, true);
                    offset += 2;
                }
                
                return new Blob([buffer], { type: 'audio/wav' });
            }

            // --- 簡易ノイズ除去（オフライン：ノイズゲート） ---
            async function reduceNoiseOffline(audioBlob) {
                if (!audioContext) {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)({ sampleRate: 48000 });
                }
                try {
                    const arrayBuffer = await audioBlob.arrayBuffer();
                    const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);

                    const numChannels = audioBuffer.numberOfChannels;
                    const outBuffer = audioContext.createBuffer(numChannels, audioBuffer.length, audioBuffer.sampleRate);

                    // パラメータ（必要に応じて調整）
                    const threshold = 0.012; // しきい値
                    const attenuation = 0.12; // 減衰率
                    const attackSamples = Math.floor(0.002 * audioBuffer.sampleRate); // 2ms
                    const releaseSamples = Math.floor(0.040 * audioBuffer.sampleRate); // 40ms

                    for (let ch = 0; ch < numChannels; ch++) {
                        const input = audioBuffer.getChannelData(ch);
                        const output = outBuffer.getChannelData(ch);
                        let gain = 1.0;
                        let env = 0.0;
                        for (let i = 0; i < input.length; i++) {
                            const x = input[i];
                            // 簡易エンベロープ追従
                            const absx = Math.abs(x);
                            if (absx > env) {
                                env += (absx - env) / Math.max(1, attackSamples);
                            } else {
                                env += (absx - env) / Math.max(1, releaseSamples);
                            }
                            // ゲート係数
                            const gate = env < threshold ? attenuation : 1.0;
                            // スムーズな遷移
                            gain += (gate - gain) * 0.1;
                            output[i] = x * gain;
                        }
                    }

                    return await audioBufferToBlob(outBuffer);
                } catch (e) {
                    console.error('ノイズ除去処理でエラーが発生しました:', e);
                    return audioBlob;
                }
            }

            // --- 台本リスト管理 ---
            function showScriptListLoading() {
                scriptList.innerHTML = `
                    <div class="flex items-center justify-center py-6 text-sm text-gray-500">
                        <span class="loading-spinner" aria-hidden="true" style="margin-right: 0.5rem;"></span>
                        <span>台本リストを読み込み中...</span>
                    </div>`;
            }

            function updateScriptList() {
                scriptList.innerHTML = '';
                
                const scriptKeys = Object.keys(allScripts);
                if (scriptKeys.length === 0) {
                    scriptList.innerHTML = '<div class="p-4 text-sm text-gray-500 text-center">台本が見つかりませんでした。</div>';
                    return;
                }

                // 全台本を表示
                scriptKeys.forEach(key => {
                    const script = allScripts[key];
                    const lines = script.lines ? script.lines.length : 0;
                    
                    const item = document.createElement('div');
                    item.className = 'flex items-center justify-between p-3 border-b border-gray-200 hover:bg-gray-50 transition-colors duration-150 cursor-pointer';
                    item.innerHTML = `
                        <div class="flex items-center flex-1">
                            <span class="script-checkbox text-lg mr-3" data-key="${key}">☐</span>
                            <span class="text-sm font-medium flex-1">${script.name} (${lines}行)</span>
                        </div>
                        ${!script.isPredefined ? `<button class="delete-script-btn text-red-500 hover:text-red-700 text-sm px-2 py-1 rounded hover:bg-red-50 ml-2" data-key="${key}">削除</button>` : ''}
                    `;
                    
                    // 項目全体のクリック処理
                    item.addEventListener('click', (e) => {
                        if (e.target.classList.contains('delete-script-btn')) return;
                        const checkbox = item.querySelector('.script-checkbox');
                        const isChecked = checkbox.textContent === '☑';
                        checkbox.textContent = isChecked ? '☐' : '☑';
                        updatePreview();
                    });
                    
                    // 削除ボタンのクリック処理
                    const deleteBtn = item.querySelector('.delete-script-btn');
                    if (deleteBtn) {
                        deleteBtn.addEventListener('click', (e) => {
                            e.stopPropagation();
                            deleteCustomScript(key);
                        });
                    }
                    
                    scriptList.appendChild(item);
                });
            }

            function loadCustomScripts() {
                const saved = localStorage.getItem('custom_scripts');
                if (saved) {
                    customScripts = JSON.parse(saved);
                }
                // allScriptsの更新は事前定義台本読み込み後に実行
            }

            function saveCustomScripts() {
                localStorage.setItem('custom_scripts', JSON.stringify(customScripts));
            }

            function saveScript() {
                const content = scriptEditor.value.trim();
                if (!content) {
                    alert('台本を入力してください。');
                    return;
                }
                
                const lines = content.split('\n').filter(line => line.trim() !== '');
                if (lines.length === 0) {
                    alert('有効な台本を入力してください。');
                    return;
                }

                // カスタム台本として保存
                const key = `custom_${Date.now()}`;
                const name = prompt('台本名を入力してください:', '新しい台本');
                if (!name) return;

                customScripts[key] = {
                    name: name,
                    lines: lines,
                    isPredefined: false
                };
                
                saveCustomScripts();
                allScripts = { ...predefinedScripts, ...customScripts };
                updateScriptList();
                
                // 新しく追加された台本を自動選択
                const newScriptCheckbox = document.querySelector(`[data-key="${key}"]`);
                if (newScriptCheckbox) {
                    newScriptCheckbox.textContent = '☑';
                }
                
                updatePreview(); // プレビューを更新
                
                // エディタをリセット
                scriptEditor.value = '';
                updateLineCount();
                
                alert('台本を保存し、自動的に選択しました。');
            }

            async function handleCustomScriptUpload(event) {
                const file = event.target.files[0];
                if (!file) return;

                const text = await file.text();
                const lines = text.split('\n').filter(line => line.trim() !== '');
                
                if (lines.length === 0) {
                    alert('有効な台本ファイルではありません。');
                    return;
                }

                // コロン（:）以前を削除して右側の文章のみを抽出
                const processedLines = lines.map(line => {
                    const colonIndex = line.indexOf(':');
                    if (colonIndex !== -1) {
                        return line.substring(colonIndex + 1).trim();
                    }
                    return line.trim();
                }).filter(line => line !== '');

                // エディタに処理済み内容を表示
                scriptEditor.value = processedLines.join('\n');
                updateLineCount();
                
                alert('台本をエディタに読み込みました。保存ボタンを押して台本を保存してください。');
            }

            function deleteCustomScript(key) {
                if (confirm('この台本を削除しますか？')) {
                    delete customScripts[key];
                    saveCustomScripts();
                    allScripts = { ...predefinedScripts, ...customScripts };
                    updateScriptList();
                    updatePreview(); // プレビューを更新
                }
            }

            // --- プレビュー機能 ---
            function initializePreview() {
                const previewHeader = document.getElementById('preview-header');
                const previewContent = document.getElementById('preview-content');
                const previewIcon = document.getElementById('preview-icon');
                const showFullPreviewBtn = document.getElementById('show-full-preview-btn');

                // プレビューの展開/折りたたみ
                previewHeader.addEventListener('click', (e) => {
                    // 詳細表示ボタンがクリックされた場合は展開/折りたたみしない
                    if (e.target === showFullPreviewBtn || e.target.closest('#show-full-preview-btn')) {
                        return;
                    }
                    
                    const isHidden = previewContent.classList.contains('hidden');
                    if (isHidden) {
                        previewContent.classList.remove('hidden');
                        previewIcon.className = 'fas fa-chevron-down text-gray-500 mr-2';
                    } else {
                        previewContent.classList.add('hidden');
                        previewIcon.className = 'fas fa-chevron-right text-gray-500 mr-2';
                    }
                });

                // 詳細表示ボタン
                showFullPreviewBtn.addEventListener('click', (e) => {
                    e.stopPropagation(); // ヘッダーのクリックイベントを防ぐ
                    toggleDetailedView();
                });
            }

            let isDetailedView = false;

            function updatePreview() {
                const selectedScripts = getSelectedScripts();
                const previewDiv = document.getElementById('script-preview');
                const previewTitle = document.getElementById('preview-title');
                const previewText = document.getElementById('preview-text');
                const previewLineCount = document.getElementById('preview-line-count');
                const showFullPreviewBtn = document.getElementById('show-full-preview-btn');
                const startBtn = document.getElementById('start-btn');

                // 録音開始ボタンの状態を更新
                if (selectedScripts.length === 0) {
                    startBtn.disabled = true;
                    previewDiv.classList.add('hidden');
                    isDetailedView = false;
                    return;
                } else {
                    startBtn.disabled = false;
                }

                previewDiv.classList.remove('hidden');

                if (selectedScripts.length === 1) {
                    const script = selectedScripts[0];
                    previewTitle.textContent = `${script.name} (${script.lines.length}行)`;
                    const previewLines = script.lines.map(line => parseText(line).displayText);
                    
                    if (isDetailedView) {
                        previewText.textContent = previewLines.join('\n');
                        showFullPreviewBtn.textContent = '簡易表示';
                    } else {
                        const summary = previewLines.slice(0, 5).join('\n');
                        previewText.textContent = summary + (previewLines.length > 5 ? '\n...' : '');
                        showFullPreviewBtn.textContent = '詳細表示';
                    }
                    previewLineCount.textContent = `${script.lines.length}行`;
                } else {
                    const totalLines = selectedScripts.reduce((sum, script) => sum + script.lines.length, 0);
                    previewTitle.textContent = `${selectedScripts.length}個の台本が選択されています (合計${totalLines}行)`;
                    
                    if (isDetailedView) {
                        previewText.textContent = selectedScripts.map(script => {
                            const previewLines = script.lines.map(line => parseText(line).displayText);
                            return `${script.name}:\n${previewLines.join('\n')}`;
                        }
                        ).join('\n\n---\n\n');
                        showFullPreviewBtn.textContent = '簡易表示';
                    } else {
                        previewText.textContent = selectedScripts.map(script => {
                            const previewLines = script.lines.map(line => parseText(line).displayText);
                            const summary = previewLines.slice(0, 2).join('\n');
                            return `${script.name}:\n${summary}${previewLines.length > 2 ? '\n...' : ''}`;
                        }
                        ).join('\n\n');
                        showFullPreviewBtn.textContent = '詳細表示';
                    }
                    previewLineCount.textContent = `合計${totalLines}行`;
                }
            }

            function toggleDetailedView() {
                isDetailedView = !isDetailedView;
                updatePreview();
            }

            function getSelectedScripts() {
                const selectedKeys = Array.from(document.querySelectorAll('#script-list .script-checkbox'))
                    .filter(checkbox => checkbox.textContent === '☑')
                    .map(checkbox => checkbox.getAttribute('data-key'));
                return selectedKeys.map(key => allScripts[key]).filter(script => script);
            }

            // --- 折りたたみ式エディタ ---
            function initializeCollapsibleEditor() {
                const editorHeader = document.getElementById('editor-header');
                const editorContent = document.getElementById('editor-content');
                const editorIcon = document.getElementById('editor-icon');

                editorHeader.addEventListener('click', () => {
                    const isHidden = editorContent.classList.contains('hidden');
                    if (isHidden) {
                        editorContent.classList.remove('hidden');
                        editorIcon.className = 'fas fa-chevron-down text-gray-500 mr-2';
                    } else {
                        editorContent.classList.add('hidden');
                        editorIcon.className = 'fas fa-chevron-right text-gray-500 mr-2';
                    }
                });
            }

            // --- 台本統合機能 ---
            function loadSelectedScripts() {
                const scripts = [];
                
                // 選択された台本を読み込み
                for (const key of selectedScripts) {
                    if (allScripts[key]) {
                        const script = allScripts[key];
                        scripts.push(...script.lines);
                    }
                }

                return scripts;
            }

            // --- Event Listeners ---
            startBtn.addEventListener('click', checkForResume);
            backBtn.addEventListener('click', () => handleShortcut('Backspace'));
            recordBtn.addEventListener('click', () => handleShortcut('Space'));
            nextBtn.addEventListener('click', () => handleShortcut('Enter'));
            playBtn.addEventListener('click', () => handleShortcut('KeyP'));
            downloadBtn.addEventListener('click', createAndDownloadFiles);
            restartBtn.addEventListener('click', () => { 
                // 内部リロードの際は警告を抑制
                shouldWarnBeforeUnload = false;
                dbAction('clear').then(() => location.reload()); 
            });
            homeBtn.addEventListener('click', () => {
                if (shouldWarnBeforeUnload) {
                    const confirmed = confirm('現在の録音進捗が失われます。ホームへ戻りますか？');
                    if (!confirmed) return;
                }
                goHome();
            });
            
            document.addEventListener('keydown', e => { 
                if (e.target.tagName !== 'INPUT' && e.target.tagName !== 'TEXTAREA' && 
                    ['Space', 'Enter', 'KeyP', 'Backspace'].includes(e.code)) { 
                    e.preventDefault(); 
                    handleShortcut(e.code); 
                } 
            });

            // ページ離脱（リロード/タブを閉じる/他ページへ遷移）時の確認
            window.addEventListener('beforeunload', (e) => {
                if (shouldWarnBeforeUnload) {
                    e.preventDefault();
                    e.returnValue = '';
                }
            });
            
            audioPlayer.addEventListener('play', () => playBtn.innerHTML = '<i class="fas fa-pause"></i>');
            audioPlayer.addEventListener('pause', () => playBtn.innerHTML = '<i class="fas fa-play"></i>');
            audioPlayer.addEventListener('ended', () => playBtn.innerHTML = '<i class="fas fa-play"></i>');
            
            // トリミング済み音声の再生
            let trimmedAudioBlob = null;
            
            // トリミング済み音声を生成する関数
            async function createTrimmedAudio(originalBlob, startRatio, endRatio) {
                try {
                    const arrayBuffer = await originalBlob.arrayBuffer();
                    const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
                    
                    const startSample = Math.floor(startRatio * audioBuffer.length);
                    const endSample = Math.floor(endRatio * audioBuffer.length);
                    const trimmedLength = endSample - startSample;
                    
                    // トリミング済みのAudioBufferを作成
                    const trimmedBuffer = audioContext.createBuffer(
                        audioBuffer.numberOfChannels,
                        trimmedLength,
                        audioBuffer.sampleRate
                    );
                    
                    // 音声データをコピー
                    for (let channel = 0; channel < audioBuffer.numberOfChannels; channel++) {
                        const originalData = audioBuffer.getChannelData(channel);
                        const trimmedData = trimmedBuffer.getChannelData(channel);
                        
                        for (let i = 0; i < trimmedLength; i++) {
                            trimmedData[i] = originalData[startSample + i];
                        }
                    }
                    
                    // AudioBufferをBlobに変換
                    return await audioBufferToBlob(trimmedBuffer);
                } catch (error) {
                    console.error('トリミング処理でエラーが発生しました:', error);
                    return originalBlob; // エラーの場合は元のBlobを返す
                }
            }
            
            // トリミング済み音声を再生する関数
            async function playTrimmedAudio() {
                if (!currentBlob) return;
                
                try {
                    // トリミング済み音声を生成
                    trimmedAudioBlob = await createTrimmedAudio(currentBlob, trimStart, trimEnd);
                    
                    // 再生用のaudio要素を作成
                    const tempAudio = new Audio();
                    tempAudio.src = URL.createObjectURL(trimmedAudioBlob);
                    
                    // 再生開始
                    await tempAudio.play();
                    
                    // 再生終了時のクリーンアップ
                    tempAudio.addEventListener('ended', () => {
                        URL.revokeObjectURL(tempAudio.src);
                    });
                    
                } catch (error) {
                    console.error('トリミング済み音声の再生でエラーが発生しました:', error);
                }
            }
            resumeContinueBtn.addEventListener('click', () => startSession(true));
            resumeNewBtn.addEventListener('click', () => startSession(false));

            // --- Core Functions ---
            function handleShortcut(code) {
                switch (code) {
                    case 'Space':
                        if (['ready', 'reviewing'].includes(appState)) { 
                            if (appState === 'reviewing') setupForRerecording(); 
                            startRecording(); 
                        }
                        else if (appState === 'recording') stopRecording();
                        break;
                    case 'Enter': 
                        if (appState === 'reviewing' && !nextBtn.disabled) goToNextLine(); 
                        break;
                    case 'KeyP': 
                        if (appState === 'reviewing') {
                            if (trimStart !== 0 || trimEnd !== 1) {
                                // トリミングが設定されている場合はトリミング済み音声を再生
                                playTrimmedAudio();
                            } else {
                                // トリミングが設定されていない場合は通常の音声を再生
                                audioPlayer.paused ? audioPlayer.play() : audioPlayer.pause();
                            }
                        }
                        break;
                    case 'Backspace': 
                        if (appState === 'ready' && currentIndex > 0) goToPreviousLine(); 
                        break;
                }
            }

            async function checkForResume() {
                // 選択された台本を取得
                selectedScripts = Array.from(document.querySelectorAll('#script-list .script-checkbox'))
                    .filter(checkbox => checkbox.textContent === '☑')
                    .map(checkbox => checkbox.getAttribute('data-key'));
                
                if (selectedScripts.length === 0) {
                    alert('台本を選択してください。');
                    return;
                }

                currentScriptKey = `combined_${Date.now()}`;
                const lastSession = await dbAction('get', `progress_${currentScriptKey}`);
                
                if (lastSession && lastSession.index > 0) {
                    resumeText.textContent = `未完了の進捗（${lastSession.index}文）があります。続きから再開しますか？`;
                    resumeModal.classList.remove('hidden');
                    setTimeout(() => resumeModal.classList.remove('opacity-0'), 10);
                } else {
                    startSession(false);
                }
            }
            
            async function startSession(resume) {
                resumeModal.classList.add('opacity-0');
                setTimeout(() => resumeModal.classList.add('hidden'), 300);

                try {
                    stream = await navigator.mediaDevices.getUserMedia({ 
                        audio: {
                            channelCount: 1,  // モノラル録音に強制
                            sampleRate: 48000,
                            echoCancellation: true,
                            noiseSuppression: true,
                            autoGainControl: true
                        }
                    });
                    audioContext = new (window.AudioContext || window.webkitAudioContext)({ sampleRate: 48000 });
                    
                    if (!resume) {
                        currentIndex = 0;
                        await dbAction('clear');
                    } else {
                        const progress = await dbAction('get', `progress_${currentScriptKey}`);
                        currentIndex = progress ? progress.index : 0;
                    }
                    
                    // 台本を統合
                    const scriptLines = loadSelectedScripts();
                    currentScript = { name: "統合台本", lines: scriptLines };
                    
                    // セッション開始：離脱確認を有効化
                    shouldWarnBeforeUnload = true;

                    initialScreen.style.display = 'none';
                    recordingScreen.style.display = 'block';
                    // 録音画面に入ったら「ホームへ戻る」を表示
                    homeBtn.style.display = 'inline-block';
                    updateDisplay();
                } catch (err) { 
                    alert("マイクへのアクセスが必要です。ブラウザの設定を確認し、マイクの使用を許可してください。"); 
                }
            }

            function goHome() {
                try {
                    if (audioPlayer) {
                        audioPlayer.pause();
                        audioPlayer.src = '';
                    }
                    if (stream) {
                        stream.getTracks().forEach(t => t.stop());
                        stream = null;
                    }
                    if (animationFrameId) {
                        cancelAnimationFrame(animationFrameId);
                        animationFrameId = null;
                    }
                    if (audioContext && audioContext.state !== 'closed') {
                        audioContext.close();
                        audioContext = null;
                    }
                    initialScreen.style.display = 'block';
                    recordingScreen.style.display = 'none';
                    completionScreen.style.display = 'none';
                    setState('idle', '録音してください');
                    resumeModal.classList.add('hidden');
                    resumeModal.classList.add('opacity-0');
                    // 初期画面に戻ったら「ホームへ戻る」を非表示
                    homeBtn.style.display = 'none';
                    // 明示的にホームに戻った場合は離脱警告を無効化
                    shouldWarnBeforeUnload = false;
                    window.scrollTo({ top: 0, behavior: 'smooth' });
                } catch (e) {
                    console.error('ホームへ戻る処理でエラーが発生しました:', e);
                }
            }

            function updateDisplay() {
                if (currentIndex >= currentScript.lines.length) { 
                    finishSession(); 
                    return; 
                }
                // テキストを解析して表示用テキストのみを表示
                const parsedText = parseText(currentScript.lines[currentIndex]);
                textDisplay.textContent = parsedText.displayText;
                progressIndicator.textContent = `${currentIndex + 1} / ${currentScript.lines.length}`;
                setupForRerecording();
            }

            function finishSession() {
                appState = 'finished';
                recordingScreen.style.display = 'none';
                completionScreen.style.display = 'block';
                // 完了画面でも「ホームへ戻る」を表示
                homeBtn.style.display = 'inline-block';
                // セッション完了：離脱確認を無効化
                shouldWarnBeforeUnload = false;
                if (stream) stream.getTracks().forEach(track => track.stop());
                if (audioContext && audioContext.state !== 'closed') audioContext.close();
            }
            
            function setState(newState, statusMessage) {
                appState = newState;
                statusText.textContent = statusMessage;
                recordBtn.disabled = !['ready', 'recording', 'reviewing'].includes(appState);
                nextBtn.disabled = appState !== 'reviewing';
                backBtn.disabled = !(appState === 'ready' && currentIndex > 0);
                
                // 再生ボタンの状態管理
                if (appState === 'reviewing') {
                    playBtn.disabled = false;
                    playBtn.className = 'w-20 h-20 bg-blue-500 hover:bg-blue-600 text-white rounded-full flex items-center justify-center text-3xl shadow-lg transition-transform transform hover:scale-110';
                } else {
                    playBtn.disabled = true;
                    playBtn.className = 'w-20 h-20 bg-gray-400 text-white rounded-full flex items-center justify-center text-3xl shadow-lg transition-transform transform hover:scale-110 disabled:bg-gray-400 disabled:cursor-not-allowed disabled:transform-none';
                }
                
                if (appState === 'recording') recordBtn.classList.add('recording'); 
                else recordBtn.classList.remove('recording');
            }
            
            function startRecording() {
                setState('recording', '録音中...');
                audioChunks = [];
                // モノラル録音を確実にするための設定
                const options = {
                    mimeType: 'audio/webm;codecs=opus',
                    audioBitsPerSecond: 192000  // 192kbpsに変更
                };
                mediaRecorder = new MediaRecorder(stream, options);
                mediaRecorder.addEventListener("dataavailable", e => audioChunks.push(e.data));
                mediaRecorder.addEventListener("stop", handleRecordingStop);
                
                // 0.5秒後に録音開始
                setTimeout(() => {
                    if (mediaRecorder && mediaRecorder.state === 'inactive') {
                        mediaRecorder.start();
                        visualizeRealtime();
                    }
                }, 500);
            }

            function stopRecording() { 
                if(mediaRecorder.state !== 'inactive') {
                    // 0.5秒後に録音停止（最後の0.5秒をカット）
                    setTimeout(() => {
                        if(mediaRecorder.state !== 'inactive') {
                            mediaRecorder.stop();
                        }
                    }, 500);
                }
                cancelAnimationFrame(animationFrameId); 
                clearCanvas(); 
            }

            async function handleRecordingStop() {
                let finalBlob = new Blob(audioChunks, { type: 'audio/wav' });

                // 48kHzで録音している前提だが、念のためAudioContextのSRに合わせて処理
                if (noiseReductionEnabled) {
                    try {
                        // まずノイズ除去（オフライン）
                        finalBlob = await reduceNoiseOffline(finalBlob);
                    } catch (e) {
                        console.error('ノイズ除去に失敗しました:', e);
                    }
                }

                // 次にノーマライズ適用（有効時）
                if (normalizeEnabled) {
                    try {
                        finalBlob = await normalizeAudio(finalBlob);
                    } catch (error) {
                        console.error('ノーマライズ処理でエラーが発生しました:', error);
                        // エラーの場合は元のBlobを使用
                    }
                }

                currentBlob = finalBlob;
                audioPlayer.src = URL.createObjectURL(currentBlob);
                setState('reviewing', '音声を確認してください');
                visualizeStatic(currentBlob);
            }
            
            async function goToNextLine() {
                if (!currentBlob) return;
                
                let finalBlob = currentBlob;
                
                // トリミングが設定されている場合はトリミング済み音声を使用
                if (trimStart !== 0 || trimEnd !== 1) {
                    try {
                        finalBlob = await createTrimmedAudio(currentBlob, trimStart, trimEnd);
                    } catch (error) {
                        console.error('トリミング処理でエラーが発生しました:', error);
                        // エラーの場合は元のBlobを使用
                    }
                }
                
                const id = `${currentScriptKey}_${String(currentIndex).padStart(4, '0')}`;
                const data = { 
                    id, 
                    scriptKey: currentScriptKey, 
                    index: currentIndex, 
                    blob: finalBlob, 
                    text: currentScript.lines[currentIndex] 
                };
                await dbAction('put', data);
                currentIndex++;
                await dbAction('put', { 
                    id: `progress_${currentScriptKey}`, 
                    scriptKey: currentScriptKey, 
                    index: currentIndex 
                });
                updateDisplay();
            }

            async function goToPreviousLine() {
                if (currentIndex <= 0) return;
                currentIndex--;
                const id = `${currentScriptKey}_${String(currentIndex).padStart(4, '0')}`;
                await dbAction('delete', id);
                await dbAction('put', { 
                    id: `progress_${currentScriptKey}`, 
                    scriptKey: currentScriptKey, 
                    index: currentIndex 
                });
                updateDisplay();
            }

            function setupForRerecording() { 
                currentBlob = null; 
                clearCanvas(); 
                // トリミング状態をリセット
                trimStart = 0;
                trimEnd = 1;
                setState('ready', '録音してください'); 
            }

            function clearCanvas() { 
                canvas.width = canvas.offsetWidth * window.devicePixelRatio; 
                canvas.height = canvas.offsetHeight * window.devicePixelRatio; 
                canvasCtx.fillStyle = '#111827'; 
                canvasCtx.fillRect(0, 0, canvas.width, canvas.height); 
            }

            function visualizeRealtime() {
                clearCanvas();
                if (!source) { 
                    analyser = audioContext.createAnalyser(); 
                    source = audioContext.createMediaStreamSource(stream); 
                    source.connect(analyser); 
                }
                analyser.fftSize = 2048; 
                const bufferLength = analyser.frequencyBinCount; 
                const dataArray = new Uint8Array(bufferLength);
                
                const draw = () => {
                    animationFrameId = requestAnimationFrame(draw); 
                    analyser.getByteTimeDomainData(dataArray); 
                    clearCanvas();
                    canvasCtx.lineWidth = 2; 
                    canvasCtx.strokeStyle = '#34d399'; 
                    canvasCtx.beginPath();
                    const sliceWidth = canvas.width / bufferLength; 
                    let x = 0;
                    for (let i = 0; i < bufferLength; i++) { 
                        const v = dataArray[i] / 128.0, y = v * canvas.height / 2; 
                        if (i === 0) canvasCtx.moveTo(x, y); 
                        else canvasCtx.lineTo(x, y); 
                        x += sliceWidth; 
                    }
                    canvasCtx.lineTo(canvas.width, canvas.height / 2); 
                    canvasCtx.stroke();
                };
                draw();
            }

            // 波形データを保存する変数
            let waveformData = null;
            
            async function visualizeStatic(blob) {
                clearCanvas(); 
                const arrayBuffer = await blob.arrayBuffer(); 
                const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
                const data = audioBuffer.getChannelData(0); 
                
                // 波形データを保存
                waveformData = data;
                
                // 波形を描画
                drawWaveform(data);
                
                // トリミング線を描画
                drawTrimLines();
            }
            
            function drawWaveform(data) {
                canvasCtx.lineWidth = 1; 
                canvasCtx.strokeStyle = '#60a5fa'; 
                canvasCtx.beginPath();
                const sliceWidth = canvas.width / data.length; 
                let x = 0;
                for (let i = 0; i < data.length; i++) { 
                    const y = (data[i] * 0.5 + 0.5) * canvas.height; 
                    if (i === 0) canvasCtx.moveTo(x, y); 
                    else canvasCtx.lineTo(x, y); 
                    x += sliceWidth; 
                }
                canvasCtx.stroke();
            }
            
            function drawTrimLines() {
                if (!waveformData) return;
                
                // キャンバスをクリアしてから波形を再描画
                clearCanvas();
                drawWaveform(waveformData);
                
                const startX = trimStart * canvas.width;
                const endX = trimEnd * canvas.width;
                
                // 選択範囲をハイライト
                canvasCtx.fillStyle = 'rgba(34, 197, 94, 0.2)';
                canvasCtx.fillRect(startX, 0, endX - startX, canvas.height);
                
                // 開始線（緑）- 太さ調整版 + ホバー効果
                const startLineWidth = (draggedTrimLine === 'start' || hoveredTrimLine === 'start') ? 5 : 3;
                const startLineColor = (draggedTrimLine === 'start') ? '#16a34a' : 
                                      (hoveredTrimLine === 'start') ? '#15803d' : '#22c55e';
                canvasCtx.strokeStyle = startLineColor;
                canvasCtx.lineWidth = startLineWidth;
                canvasCtx.beginPath();
                canvasCtx.moveTo(startX, 0);
                canvasCtx.lineTo(startX, canvas.height);
                canvasCtx.stroke();
                
                // 終了線（赤）- 太さ調整版 + ホバー効果
                const endLineWidth = (draggedTrimLine === 'end' || hoveredTrimLine === 'end') ? 5 : 3;
                const endLineColor = (draggedTrimLine === 'end') ? '#dc2626' : 
                                    (hoveredTrimLine === 'end') ? '#b91c1c' : '#ef4444';
                canvasCtx.strokeStyle = endLineColor;
                canvasCtx.lineWidth = endLineWidth;
                canvasCtx.beginPath();
                canvasCtx.moveTo(endX, 0);
                canvasCtx.lineTo(endX, canvas.height);
                canvasCtx.stroke();
                
                // ハンドル（四角形）を描画
                drawTrimHandles(startX, endX);
            }
            
            function drawTrimHandles(startX, endX) {
                const handleSize = 20;
                const handleY = 8;
                
                // ハサミの絵文字を描画（最前面、透過なし）
                canvasCtx.font = '16px Arial';
                canvasCtx.textAlign = 'center';
                canvasCtx.textBaseline = 'top';
                canvasCtx.globalAlpha = 1.0; // 透過なし
                
                // 開始線のハンドル（ハサミ絵文字）
                // 白い縁取りを描画
                canvasCtx.strokeStyle = '#ffffff';
                canvasCtx.lineWidth = 3;
                canvasCtx.strokeText('✂️', startX, handleY);
                // 黒い文字を描画
                canvasCtx.fillStyle = '#000000';
                canvasCtx.fillText('✂️', startX, handleY);
                
                // 終了線のハンドル（ハサミ絵文字）
                // 白い縁取りを描画
                canvasCtx.strokeStyle = '#ffffff';
                canvasCtx.lineWidth = 3;
                canvasCtx.strokeText('✂️', endX, handleY);
                // 黒い文字を描画
                canvasCtx.fillStyle = '#000000';
                canvasCtx.fillText('✂️', endX, handleY);
            }

            async function createAndDownloadFiles() {
                downloadBtn.disabled = true; 
                downloadSpinner.style.display = 'block';
                
                try {
                    const allData = await dbAction('getAll');
                    const recordings = allData.filter(d => d.scriptKey === currentScriptKey && d.blob);
                    
                    // 必ずZIPファイルを生成
                    await createZipFile(recordings);
                } catch(e) { 
                    console.error("ファイル生成に失敗:", e); 
                    alert("ファイルの生成に失敗しました。"); 
                }
                finally { 
                    downloadBtn.disabled = false; 
                    downloadSpinner.style.display = 'none'; 
                }
            }

            async function createZipFile(recordings) {
                const zip = new JSZip(); 
                const audioFolder = zip.folder('raw');
                let transcript = '';
                
                // 選択されたエクスポート形式を取得
                const selectedFormat = exportFormats.formats.find(f => f.id === exportFormat);
                if (!selectedFormat) {
                    throw new Error('選択されたエクスポート形式が見つかりません');
                }
                
                recordings.sort((a,b) => a.index - b.index).forEach(data => {
                    const filename = `audio_${String(data.index + 1).padStart(4, '0')}.wav`;
                    audioFolder.file(filename, data.blob); 
                    
                    // テキストを解析
                    const parsedText = parseText(data.text);
                    
                    // 選択された形式に応じてトランスクリプトを生成
                    if (selectedFormat.id === 'style_bert_vits2') {
                        // Style-BERT-VITS2形式（表示用テキストからルビを除去）
                        const cleanText = removeRuby(parsedText.displayText);
                        transcript += `${filename}|${speakerName.value}|${language.value}|${cleanText}\n`;
                    } else if (selectedFormat.id === 'ljspeech') {
                        // LJSpeech形式（表示用テキストと正規化テキストの両方使用、ルビはそのまま）
                        const filenameId = filename.replace('.wav', ''); // 拡張子を除去
                        transcript += `${filenameId}|${parsedText.displayText}|${parsedText.normalizedText}\n`;
                    } else if (selectedFormat.id === 'simple') {
                        // シンプル形式（表示用テキストからルビを除去）
                        const cleanText = removeRuby(parsedText.displayText);
                        transcript += `${filename}|${cleanText}\n`;
                    }
                });
                
                // 選択された形式に応じてファイル名を設定
                zip.file(selectedFormat.outputFile, transcript);
                
                // ZIPファイル生成の設定を改善
                const content = await zip.generateAsync({ 
                    type: 'blob',
                    compression: 'DEFLATE',
                    compressionOptions: {
                        level: 6
                    }
                });
                
                // 現在の日時をファイル名に含める
                const now = new Date();
                const year = now.getFullYear();
                const month = String(now.getMonth() + 1).padStart(2, '0');
                const day = String(now.getDate()).padStart(2, '0');
                const hours = String(now.getHours()).padStart(2, '0');
                const minutes = String(now.getMinutes()).padStart(2, '0');
                const seconds = String(now.getSeconds()).padStart(2, '0');
                const timestamp = `${year}-${month}-${day}-${hours}-${minutes}-${seconds}`;
                
                const link = document.createElement('a'); 
                link.href = URL.createObjectURL(content); 
                link.download = `koerec_${timestamp}.zip`;
                document.body.appendChild(link); 
                link.click(); 
                document.body.removeChild(link);
                
                // メモリリークを防ぐためURLを解放
                setTimeout(() => {
                    URL.revokeObjectURL(link.href);
                }, 1000);
            }


            // トリミング機能のマウスイベント
            canvas.addEventListener('mousedown', handleTrimMouseDown);
            canvas.addEventListener('mousemove', handleTrimMouseMove);
            canvas.addEventListener('mouseup', handleTrimMouseUp);
            canvas.addEventListener('mouseleave', handleTrimMouseUp);
            canvas.addEventListener('mousemove', handleTrimMouseHover);
            
            // トリミング機能のマウスイベントハンドラー
            function handleTrimMouseDown(e) {
                if (appState !== 'reviewing') return;
                
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left; // CSSピクセル
                const clickRatio = x / canvas.offsetWidth; // CSS幅基準で比率を算出
                
                // 最も近い線を選択
                const startDistance = Math.abs(clickRatio - trimStart);
                const endDistance = Math.abs(clickRatio - trimEnd);
                
                if (startDistance < endDistance && startDistance < 0.05) {
                    draggedTrimLine = 'start';
                } else if (endDistance < 0.05) {
                    draggedTrimLine = 'end';
                } else {
                    return;
                }
                
                isDraggingTrim = true;
                canvas.style.cursor = 'ew-resize';
            }
            
            function handleTrimMouseMove(e) {
                if (isDraggingTrim && draggedTrimLine) {
                    const rect = canvas.getBoundingClientRect();
                    const x = e.clientX - rect.left; // CSSピクセル
                    const newRatio = Math.max(0, Math.min(1, x / canvas.offsetWidth)); // CSS幅基準
                    
                    if (draggedTrimLine === 'start') {
                        trimStart = Math.min(newRatio, trimEnd - 0.01); // 終了線より前に制限
                    } else if (draggedTrimLine === 'end') {
                        trimEnd = Math.max(newRatio, trimStart + 0.01); // 開始線より後に制限
                    }
                    
                    // トリミング線のみを再描画
                    drawTrimLines();
                }
            }
            
            function handleTrimMouseHover(e) {
                if (appState !== 'reviewing' || isDraggingTrim) return;
                
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left; // CSSピクセル
                const y = e.clientY - rect.top; // CSSピクセル
                const clickRatio = x / canvas.offsetWidth; // CSS幅基準
                
                // ハンドルの範囲をチェック（絵文字サイズに調整）
                const handleSize = 20;
                const handleY = 8;
                const startX = trimStart * canvas.offsetWidth; // CSS幅基準
                const endX = trimEnd * canvas.offsetWidth; // CSS幅基準
                
                let newHoveredLine = null;
                let newCursor = 'default';
                
                // 開始線のハンドルをチェック
                if (x >= startX - handleSize/2 && x <= startX + handleSize/2 && 
                    y >= handleY && y <= handleY + handleSize) {
                    newHoveredLine = 'start';
                    newCursor = 'ew-resize';
                }
                // 終了線のハンドルをチェック
                else if (x >= endX - handleSize/2 && x <= endX + handleSize/2 && 
                         y >= handleY && y <= handleY + handleSize) {
                    newHoveredLine = 'end';
                    newCursor = 'ew-resize';
                }
                // 縦線全体をチェック（ハンドル以外）
                else if (Math.abs(clickRatio - trimStart) < 0.02) {
                    newHoveredLine = 'start';
                    newCursor = 'ew-resize';
                }
                else if (Math.abs(clickRatio - trimEnd) < 0.02) {
                    newHoveredLine = 'end';
                    newCursor = 'ew-resize';
                }
                
                // ホバー状態が変わった場合のみ再描画
                if (newHoveredLine !== hoveredTrimLine) {
                    hoveredTrimLine = newHoveredLine;
                    canvas.style.cursor = newCursor;
                    drawTrimLines();
                }
            }
            
            function handleTrimMouseUp(e) {
                isDraggingTrim = false;
                draggedTrimLine = null;
                canvas.style.cursor = 'default';
            }

            // アプリケーション初期化
            initializeApp();
        });
    </script>
</body>
</html>
